package Xconfig::xfree; # $Id$

my ($Revision) = '$Revision$' =~ /(\d+)/;

use diagnostics;
use strict;

use common;
use Xconfig::parse;

#- mostly internal only
sub new {
    my ($class, $raw) = @_;
    @$raw && bless { raw => $raw }, $class;
}

sub _conf_file() {
    "$::prefix/etc/X11/xorg.conf";
}

################################################################################
# I/O ##########################################################################
################################################################################
sub read {
    my ($class) = @_;
    my $raw_X = $class->new(Xconfig::parse::read_XF86Config(_conf_file())) or return;
    $raw_X->{before} = $raw_X->prepare_write;

    if (my ($keyboard) = $raw_X->get_InputDevices('keyboard')) {
	$keyboard->{Driver}{val} = 'kbd';
    }
    if (my ($keyboard) = $raw_X->get_InputDevices('Keyboard')) {
	$keyboard->{Driver}{val} = 'kbd';
    }

    #- ugly hack to fix empty ModeLine lines, XFdrake seems to generate some, but where???
    #- at least this allows fixing the pb by re-running XFdrake 
    foreach ($raw_X->get_Sections('Monitor')) {
	my $l = $_->{ModeLine} or next;
	@$l = grep { $_->{val} } @$l;
    }

    foreach ($raw_X->get_Sections('Device')) {
	$_->{Driver} && $_->{Driver}{val} eq 'i810' and $_->{Driver}{val} = 'intel';
    }

    $raw_X;
}
sub write {
    my ($raw_X, $o_file) = @_;
    my $file = $o_file || _conf_file();
    if (!$o_file) {
	renamef($file, "$file.old");
    }
    no_ModeLine_on_fglrx($raw_X); #- HACK
    set_Revision($raw_X);
    Xconfig::parse::write_XF86Config($raw_X->{raw}, $file);
}
sub prepare_write {
    my ($raw_X) = @_;
    set_Revision($raw_X);
    join('', Xconfig::parse::prepare_write_XF86Config($raw_X->{raw}));
}
sub is_modified {
    my ($raw_X) = @_;
    $raw_X->{before} ne $raw_X->prepare_write;
}
sub is_only_resolution_modified {
    my ($raw_X) = @_;
    ($raw_X->{after_set_resolutions} || $raw_X->{before}) eq $raw_X->prepare_write;
}
sub empty_config {
    my ($class) = @_;
    $class->new(Xconfig::parse::read_XF86Config_from_string(our $default_header));
}

my $mark = '# File generated by XFdrake';
sub get_Revision {
    my ($raw_X) = @_;
    my $first = $raw_X->{raw}[0];
    $first->{pre_comment} =~ /^\Q$mark\E \(rev (\d+)\)/ && $1;
}
sub set_Revision {
    my ($raw_X) = @_;
    my $first = $raw_X->{raw}[0];
    my $first_comment = $first->{pre_comment};

    my $was_there = $first_comment =~ s/^\Q$mark\E.*\n//;
    $first->{pre_comment} = "$mark (rev $Revision)\n" . ($was_there ? '' : "\n") . $first_comment;
}

################################################################################
# keyboard #####################################################################
################################################################################
my @keyboard_fields = qw(XkbLayout XkbModel XkbDisable XkbOptions XkbCompat);
sub get_keyboard {
    my ($raw_X) = @_;
    my $raw_kbd = _raw_get_keyboard($raw_X) or die "no keyboard section";
    raw_export_section($raw_kbd, \@keyboard_fields);
}
sub _raw_get_keyboard {
    my ($raw_X) = @_;
    first($raw_X->get_Sections('InputDevice', sub { 
	my ($entry) = @_;
	my $Driver = val($entry->{Driver});
	$Driver eq 'kbd' || $Driver eq 'evdev' && val($entry->{XkbLayout});
    }));
}

################################################################################
# mouse ########################################################################
################################################################################
#- example mouse: { Protocol => 'IMPS/2', Device => '/dev/psaux', Emulate3Buttons => undef, Emulate3Timeout => 50, ZAxisMapping => [ '4 5', '6 7' ] }
#- example evdev: { bustype => '0x0003', vendor => '0x045e', product => '0x008c' }
my @mouse_fields = qw(Protocol Device ZAxisMapping Emulate3Buttons Emulate3Timeout bustype vendor product); #-);
sub get_mice {
    my ($raw_X) = @_;
    my @raw_mice = $raw_X->get_Sections('InputDevice', \&_is_mouse);
    map { raw_export_section($_, \@mouse_fields) } @raw_mice;
}
sub set_mice {
    my ($raw_X, @mice) = @_;
    @mice =  grep { $_->{Driver} && $_->{Driver} ne 'evdev' } @mice;
    my @raw_mice = _new_mouse_sections($raw_X, map { delete $_->{Driver} } @mice);
    mapn { 
	my ($raw_mouse, $mouse) = @_;
	raw_import_section($raw_mouse, $mouse);
	_set_Option('mouse', $raw_mouse, keys %$mouse);
    } \@raw_mice, \@mice;
}
sub _is_mouse {
    my ($entry) = @_;
    my $Driver = val($entry->{Driver});
    member($Driver, qw(mouse vboxmouse vmmouse)) || $Driver eq 'evdev' && !val($entry->{XkbLayout});
}
sub _new_mouse_sections {
    my ($raw_X, @Drivers) = @_;
    $raw_X->remove_InputDevices_when(\&_is_mouse);
    
    @Drivers or return;
    
    my @l = map_index {
	my $h = { Identifier => { val => 'Mouse' . ($::i + 1) }, Driver => { val => $_ } };
	$raw_X->add_Section('InputDevice', $h);
    } @Drivers;

    my $layout = get_ServerLayout($raw_X)->{InputDevice} ||= [];    
    push @$layout, { val => qq("Mouse1" "CorePointer") };
    push @$layout, { val => qq("Mouse$_" "SendCoreEvents") } foreach 2 .. @Drivers;
    
    @l;
}


################################################################################
# resolution ###################################################################
################################################################################
sub get_resolution {
    my ($raw_X, $o_Screen) = @_;
    first(get_resolutions($raw_X, $o_Screen));
}
sub get_resolutions {
    my ($raw_X, $o_Screen) = @_;
    my $Screen = $o_Screen || $raw_X->get_default_screen or return {};
    
    my $depth = val($Screen->{DefaultColorDepth} || $Screen->{DefaultDepth});
    my $Display = find { !$depth || val($_->{l}{Depth}) eq $depth } @{$Screen->{Display} || []} or return { automatic => 1, Depth => $depth };
    my $s = val($Display->{l}{Virtual} || $Display->{l}{Modes});
    my @l;
    while ($s =~ /(\d+)(x|\s+)(\d+)/g) {
	push @l, { X => $1, Y => $3, Depth => val($Display->{l}{Depth}) };
    }
    @l ? @l : { automatic => 1, Depth => $depth };
}
sub set_resolutions {
    my ($raw_X, $resolutions, $o_Screen) = @_;
    
    my $Depth = $resolutions->[0]{Depth} eq '32' ? 24 : $resolutions->[0]{Depth};
    my $only_resolution = $raw_X->is_only_resolution_modified;
    
    foreach my $Screen ($o_Screen ? $o_Screen : $raw_X->get_Sections('Screen')) {
	$Screen ||= $raw_X->get_default_screen or internal_error('no screen');
	
	delete $Screen->{DefaultDepth};
	$only_resolution &&= $Screen->{DefaultColorDepth} && $Screen->{DefaultColorDepth}{val} eq $Depth;
	if ($resolutions->[0]{X}) {
	    #- if the existing config is using Virtual, keep Virtual, otherwise default to Modes
	    my $Mode_name = (any { $_->{l}{Virtual} } @{$Screen->{Display} || []}) ? 'Virtual' : 'Modes';

	    my @l = $Mode_name eq 'Modes' ? @$resolutions : first(@$resolutions);
	    my @Modes = map { sprintf($Mode_name eq 'Modes' ? '"%dx%d"' : '%d %d', @$_{'X', 'Y'}) } @l;

	    $Screen->{Display} = [ map {
		{ l => { Depth => { val => $_ }, $Mode_name => { val => join(' ', @Modes) } } };
	    } 8, 15, 16, 24 ];
	} else {
	    delete $Screen->{Display};
	}
	if ($Depth) {
	    $Screen->{DefaultColorDepth} = { val => $Depth };
	} else {
	    delete $Screen->{DefaultColorDepth};
	}
    }
    add_gtf_ModeLines($raw_X, $resolutions) if $resolutions->[0]{X};

    $raw_X->{after_set_resolutions} = $only_resolution ? $raw_X->prepare_write : '';
}


################################################################################
# device #######################################################################
################################################################################
my @device_fields = qw(VendorName BoardName Driver VideoRam Screen BusID); #-);
sub get_device {
    my ($raw_X) = @_;
    first(get_devices($raw_X));
}
sub get_devices {
    my ($raw_X) = @_;
    my @raw_devices = $raw_X->get_Sections('Device');
    map {
	my $raw_device = $_;
	my $device = raw_export_section($raw_device, [ 'Identifier', @device_fields ]);
	$device->{Options} = raw_export_section($raw_device, [ grep { (deref_array($raw_device->{$_}))[0]->{Option} } keys %$raw_device ]);
	$device;
    } @raw_devices;
}
sub set_devices {
    my ($raw_X, @devices) = @_;
    my @raw_devices = _new_device_sections($raw_X, int @devices);
    mapn { 
	my ($raw_device, $device) = @_;
	my %Options  = %{$device->{Options} || {}};
	raw_import_section($raw_device, $device, \@device_fields);
	raw_import_section($raw_device, \%Options);
	$_->{Option} = 1 foreach map { deref_array($raw_device->{$_}) } keys %Options;
	$raw_device->{''} = [ { post_comment => $device->{raw_LINES} } ] if $device->{raw_LINES};
    } \@raw_devices, \@devices;
}
sub _new_device_sections {
    my ($raw_X, $nb_new) = @_;
    $raw_X->remove_Section('Device');
    map { $raw_X->add_Section('Device', { Identifier => { val => "device$_" }, DPMS => { Option => 1 } }) } (1 .. $nb_new);
}
sub get_Driver {
    my ($raw_X) = @_;
    my $card = eval { $raw_X->get_device };
    $card && $card->{Driver};
}

################################################################################
# wacoms #######################################################################
################################################################################
sub set_wacoms {
    my ($raw_X, @wacoms) = @_;
    $raw_X->remove_InputDevices('wacom');
    
    @wacoms or return;
    
    my @Modes = ('Stylus', 'Eraser', 'Cursor', 'Pad');
   
    my $layout = get_ServerLayout($raw_X)->{InputDevice} ||= [];    
    each_index {
	my $wacom = $_;
	foreach (@Modes) {
	    next if $wacom->{USB};
	    my $identifier = $_ . ($::i + 1);
	    my $h = { Identifier => { val => $identifier }, 
		      Driver => { val => 'wacom' },
		      Type => { val => lc $_, Option => 1 },
		      Device => { val => $wacom->{Device}, Option => 1 }
		    };
	    $raw_X->add_Section('InputDevice', $h);
	    push @$layout, { val => qq("$identifier" "SendCoreEvents") };
	}
    } @wacoms;
}

################################################################################
# monitor ######################################################################
################################################################################
my @monitor_fields = qw(VendorName ModelName HorizSync VertRefresh PreferredMode);
sub get_monitors {
    my ($raw_X) = @_;
    my @raw_monitors = $raw_X->get_Sections('Monitor');
    map { 
	my $h = raw_export_section($_, [ 'Identifier', @monitor_fields ]);
	$h->{ModeLine} = $_->{ModeLine} if $_->{ModeLine};
	$h;
    } @raw_monitors;
}
sub set_monitors {
    my ($raw_X, @monitors) = @_;
    my @raw_monitors = _new_monitor_sections($raw_X, int @monitors);
    mapn { 
	my ($raw_monitor, $monitor) = @_;
	raw_import_section($raw_monitor, $monitor, \@monitor_fields);
	$raw_monitor->{PreferredMode}{Option} = 1 if $raw_monitor->{PreferredMode};
	$raw_monitor->{ModeLine} = $monitor->{ModeLine} if $monitor->{ModeLine};
    } \@raw_monitors, \@monitors;
}
sub get_or_new_monitors {
    my ($raw_X, $nb_new) = @_;
    my @monitors = $raw_X->get_monitors;

    #- ensure we have exactly $nb_new monitors;
    if ($nb_new > @monitors) {
	@monitors, ({}) x ($nb_new - @monitors);
    } else {
	splice(@monitors, 0, $nb_new);
    }
}
sub _new_monitor_sections {
    my ($raw_X, $nb_new) = @_;
    $raw_X->remove_Section('Monitor');
    map { $raw_X->add_Section('Monitor', { Identifier => { val => "monitor$_" }, ModeLine => default_ModeLine() }) } (1 .. $nb_new);
}
sub default_ModeLine() {
    ModeLine_from_string(qq(Section "Monitor"\n) . (our $default_ModeLine) . qq(EndSection\n));
}

sub XxY {
    my ($resolution) = @_;
    $resolution && $resolution->{X} && $resolution->{Y} && 
      $resolution->{X} . 'x' . $resolution->{Y};
}

sub xorg_builtin_resolution {
    my ($X, $Y) = @_;
    my $res = $X . 'x' . $Y;

    $res eq '1280x1024' ||
      $res ne '1400x1050' && $res ne '1152x864' && $Xconfig::xfree::resolution2ratio{$res} eq '4/3';
}

sub resolution2ratio {
    my ($resolution, $b_non_strict) = @_;
    my $res = XxY($resolution);
    $res eq '1280x1024' && $b_non_strict ? '4/3' : $Xconfig::xfree::resolution2ratio{$res};
}

sub add_gtf_ModeLines {
    my ($raw_X, $resolutions) = @_;

    my $banner = 'modeline generated by gtf(1) [handled by XFdrake]';
    my @to_add;
    if (!xorg_builtin_resolution($resolutions->[0]{X}, $resolutions->[0]{Y})) {
	@to_add = map { 
	  my $resolution = $_;
	  map {
	    my $s = run_program::rooted_get_stdout($::prefix, 'gtf', $resolution->{X}, $resolution->{Y}, $_);
	    if (my ($name, $val) = $s =~ /ModeLine\s*"(.*)"(.*)/i) {
		chomp $val;
		$name =~ s/\.00//;	#- nicer that way
		{ val => qq("${name}"$val), pre_comment => "# $banner\n" };
	    } else { () }
	  } reverse(sort_numbers(@Xconfig::xfree::vfreqs));
	} @$resolutions;
    }

    $raw_X->set_monitors(map {
	@{$_->{ModeLine}} = (
	    (grep { index($_->{pre_comment}, $banner) == -1 } @{$_->{ModeLine}}),
	    @to_add,
	);
	$_;
    } $raw_X->get_monitors);
    
    1;
}

#- HACK for fglrx (#30934)
sub no_ModeLine_on_fglrx {
    my ($raw_X) = @_;

    if (get_Driver($raw_X) eq 'fglrx') {
	delete $_->{ModeLine} foreach $raw_X->get_Sections('Monitor');
    }
}

################################################################################
# screens ######################################################################
################################################################################
sub get_default_screen {
    my ($raw_X) = @_;
    my @l = $raw_X->get_Sections('Screen');
    (find { $_->{Identifier} && val($_->{Identifier}) eq 'screen1' || 
	      $_->{Driver} && val($_->{Driver}) =~ /svga|accel/ } @l) || $l[0];
}
sub set_screens {
    my ($raw_X, @screens) = @_;
    my @raw_screens = _new_screen_sections($raw_X, int @screens);
    mapn { 
	my ($raw_screen, $screen) = @_;
	raw_import_section($raw_screen, $screen);
    } \@raw_screens, \@screens;
}
sub _new_screen_sections {
    my ($raw_X, $nb_new) = @_;
    $raw_X->remove_Section('Screen');
    my @l = map { $raw_X->add_Section('Screen', { Identifier => { val => "screen$_" } }) } (1 .. $nb_new);

    get_ServerLayout($raw_X)->{Screen} = [ 
	{ val => qq("screen1") },
	map { { val => sprintf('"screen%d" RightOf "screen%d"', $_, $_ - 1) } } (2 .. $nb_new)
    ];
    @l;
}
sub is_fbdev {
    my ($raw_X, $o_Screen) = @_;

    my $Screen = $o_Screen || $raw_X->get_default_screen or return;

    my $Device = $raw_X->get_Section_by_Identifier('Device', val($Screen->{Device})) or internal_error("no device named $Screen->{Device}");
    val($Device->{Driver}) eq 'fbdev';
}




################################################################################
# modules ######################################################################
################################################################################
sub get_modules {
    my ($raw_X) = @_;
    my $raw_Module = $raw_X->get_Section('Module') or return;
    my $Module = raw_export_section($raw_Module, ['Load']);
    @{$Module->{Load} || []};
}
sub get_disabled_modules {
    my ($raw_X) = @_;
    my $raw_Module = $raw_X->get_Section('Module') or return;
    my $Module = raw_export_section($raw_Module, ['Disable']);
    @{$Module->{Disable} || []};
}
sub add_load_module {
    my ($raw_X, $module) = @_;
    my $raw_Module = $raw_X->get_Section('Module') || $raw_X->add_Section('Module', {});

    my %load_modules_comment = (
	dbe => 'Double-Buffering Extension',
	v4l => 'Video for Linux',
	dri => 'direct rendering',
	glx => '3D layer',
	'glx-3.so' => '3D layer',
    );
    my $comment = $load_modules_comment{$module};
    push @{$raw_Module->{Load}}, { val => $module,
				   comment_on_line => $comment && " # $comment",
				 } if !member($module, $raw_X->get_modules);
}
sub add_disable_module {
    my ($raw_X, $module) = @_;
    my $raw_Module = $raw_X->get_Section('Module') || $raw_X->add_Section('Module', {});

    push @{$raw_Module->{Disable}}, { val => $module } if !member($module, $raw_X->get_disabled_modules);
}
sub remove_load_module {
    my ($raw_X, $module) = @_;
    my $raw_Module = $raw_X->get_Section('Module') or return;
    if (my @l = grep { $_->{val} ne $module } @{$raw_Module->{Load}}) {
	$raw_Module->{Load} = \@l;
    } else {
	delete $raw_Module->{Load};
    }
}
sub remove_disable_module {
    my ($raw_X, $module) = @_;
    my $raw_Module = $raw_X->get_Section('Module') or return;
    if (my @l = grep { $_->{val} ne $module } @{$raw_Module->{Disable}}) {
	$raw_Module->{Disable} = \@l;
    } else {
	delete $raw_Module->{Disable};
    }
}
sub set_load_module {
    my ($raw_X, $module, $bool) = @_;
    if ($bool) { 
	remove_disable_module($raw_X, $module);
	add_load_module($raw_X, $module);
    } else {
	remove_load_module($raw_X, $module);
	add_disable_module($raw_X, $module);
    }
}


################################################################################
# modules ######################################################################
################################################################################
sub remove_extension {
    my ($raw_X, $extension) = @_;
    my $raw = $raw_X->get_Section('Extensions') or return;
    delete $raw->{$extension};
    %$raw or $raw_X->remove_Section('Extensions');
}
sub get_extension {
    my ($raw_X, $extension) = @_;
    my $raw = $raw_X->get_Section('Extensions');
    $raw && $raw->{$extension} && $raw->{$extension}{val};
}
sub set_extension {
    my ($raw_X, $extension, $val) = @_;
    my $raw = $raw_X->get_Section('Extensions') || $raw_X->add_Section('Extensions', {});
    $raw->{$extension} = { 'Option' => 1, val => $val };
}

################################################################################
# ModulePath ###################################################################
################################################################################
sub get_ModulePaths {
    my ($raw_X) = @_;
    my $raw_Files = $raw_X->get_Section('Files') or return;
    my $Files = raw_export_section($raw_Files, ['ModulePath']);
    @{$Files->{ModulePath} || []};
}
sub add_ModulePath {
    my ($raw_X, $ModulePath) = @_;
    my $raw_Files = $raw_X->get_Section('Files') || $raw_X->add_Section('Files', {});

    push @{$raw_Files->{ModulePath}}, { val => $ModulePath } if !member($ModulePath, $raw_X->get_ModulePaths);
}
sub remove_ModulePath {
    my ($raw_X, $ModulePath) = @_;
    my $raw_Files = $raw_X->get_Section('Files') or return;
    my @l = grep { $_->{val} ne $ModulePath && $_->{val} ne "$ModulePath/" } @{$raw_Files->{ModulePath}};
    $raw_Files->{ModulePath} = \@l;
}

#-##############################################################################
#- helpers
#-##############################################################################
sub _set_Option {
    my ($category, $node, @names) = @_;
    
    if (member($category, 'keyboard', 'mouse')) {
	#- everything we export is an Option
	$_->{Option} = 1 foreach map { deref_array($node->{$_}) } @names;
    }
}

sub get_InputDevices {
    my ($raw_X, $Driver) = @_;
    $raw_X->get_Sections('InputDevice', sub { val($_[0]{Driver}) eq $Driver });
}
sub remove_InputDevices {    
    my ($raw_X, $Driver) = @_;
    $raw_X->remove_InputDevices_when(sub { val($_[0]{Driver}) eq $Driver });
}
sub remove_InputDevices_when {    
    my ($raw_X, $when) = @_;
    my @removed = $raw_X->remove_Section('InputDevice', $when);

    my $Identifier_regexp = join('|', map { val($_->{l}{Identifier}) } @removed);
    my $layout = get_ServerLayout($raw_X)->{InputDevice} ||= [];
    @$layout = grep { $_->{val} !~ /^"$Identifier_regexp"/ } @$layout;
}

sub get_ServerLayout {
    my ($raw_X) = @_;
    $raw_X->get_Section('ServerLayout') ||
      $raw_X->add_Section('ServerLayout', { Identifier => { val => 'layout1' } });
}

#-##############################################################################
#- helpers
#-##############################################################################
sub raw_export_section {
    my ($section, $fields) = @_;

    my $export_name = sub {
	my ($name) = @_;
	my $h = $section->{$name} or return;

	my @l = map { if_(!$_->{commented}, $_->{val}) } deref_array($h) or return;    
	$name => (ref($h) eq 'ARRAY' ? \@l : $l[0]);
    };

    my %h = map { $export_name->($_) } @$fields;
    \%h;
}

sub raw_import_section {
    my ($section, $h, $o_fields) = @_;
    foreach ($o_fields ? grep { exists $h->{$_} } @$o_fields : sort keys %$h) {
	my @l = map { ref($_) eq 'HASH' ? $_ : { val => $_ } } deref_array($h->{$_});
	$section->{$_} = (ref($h->{$_}) eq 'ARRAY' ? \@l : $l[0]);
    }
}

sub add_Section {
    my ($raw_X, $Section, $h) = @_;
    my @suggested_ordering = qw(Extensions Files ServerFlags Module DRI Keyboard Pointer XInput InputDevice Monitor Device Screen ServerLayout);
    my %order = map_index { { lc($_) => $::i } } @suggested_ordering;
    my $e = { name => $Section, l => $h };
    my $added;
    my $raw = $raw_X->{raw};
    @$raw = map { 
	if ($order{lc $_->{name}} > $order{lc $Section} && !$added) {
	    $added = 1;
	    ($e, $_);
	} else { $_ }
    } @$raw;
    push @$raw, $e if !$added;
    $h;
}
sub remove_Section {
    my ($raw_X, $Section, $o_when) = @_;
    my $raw = $raw_X->{raw};
    my ($keep, $remove) = partition { $_->{name} ne $Section || $o_when && !$o_when->($_->{l}) } @$raw;
    @$raw = @$keep;
    @$remove;
}
sub get_Sections {
    my ($raw_X, $Section, $o_when) = @_;
    map { if_(lc($_->{name}) eq lc($Section) && (!$o_when || $o_when->($_->{l})), $_->{l}) } @{$raw_X->{raw}};
}
sub get_Section {
    my ($raw_X, $Section, $o_when) = @_;
    my @l = get_Sections($raw_X, $Section, $o_when);
    @l > 1 and log::l("Xconfig: found more than one Section $Section");
    $l[0];
}
sub get_Section_by_Identifier {
    my ($raw_X, $Section, $Identifier) = @_;
    my @l = get_Sections($raw_X, $Section, sub { val($_[0]{Identifier}) eq $Identifier });
    @l > 1 and die "more than one Section $Section has Identifier $Identifier";
    $l[0];
}

sub val {
    my ($ref) = @_;
    $ref && $ref->{val};
}


sub ModeLine_from_string {
    my ($s) = @_;
    my $raw_X_for_ModeLine = Xconfig::parse::read_XF86Config_from_string($s);
    get_Section(Xconfig::xfree->new($raw_X_for_ModeLine), 'Monitor')->{ModeLine};
}



# http://home.comcast.net/~igpl/Aspect.html
# movies http://www.technosound.co.uk/nav.php?pageid=hcg_widescreen
# esp for 1360x768 http://www.winischhofer.at/linuxsispart1.shtml

# www.dell.com/downloads/global/vectors/2003_cvt.pdf
# file vesamodes in Xorg is DMT Standard Display Modes

# http://www.vesa.org/Public
# http://www.vesa.org/Public/EEDIDguideV1.pdf 

#- http://www.vesa.org/Public/CVT
our @CVT_ratios = qw(4/3 16/9 16/10 5/4 15/9 3/2);
our @CVT_vfreqs = qw(50 60 75 85); # and also 60Hz "reduced blanking" in CVT

our @vfreqs = (@CVT_vfreqs, qw(100 120));

our %ratio2resolutions = (

    # first all the CVT_ratios

    # 1.25
    '5/4' => [ '640x512',
	       '720x576',
	       '1280x1024', # SXGA
	       '1800x1440',
	       #'2560x2048', # QSXGA
	       #'5120x4096', # HSXGA
	   ],

    # 1.33
    '4/3' => [ '320x240', # QVGA
	       '480x360',
	       '640x480', # VGA
	       #'768x576', # PAL
	       '800x600', # SVGA
	       '832x624',
	       '1024x768', # XGA
	       '1152x864',
	       '1280x960',
	       '1400x1050', # SXGA+
	       '1600x1200', # UXGA
	       #'1792x1344',
	       #'1800x1350',
	       #'1856x1392',
	       '1920x1440',
	       '2048x1536', # QXGA
	       '2800x2100', # QSXGA+
	       '3200x2400', # QUXGA
	       '4096x3072', # HXGA
	       '6400x4800', # HUXGA
	       # DBLSCAN: 400x300 416x312 512x384 576x432 700x525 896x672 928x696 960x720
    ],

    # 1.5
    '3/2' => [ '360x240',
	       '720x480', # NTSC 
	       '1152x768',
	       #'1280x854',
	       #'1440x960',
	   ], # 576x384 (DBLSCAN of 1152x768)

    # 1.6
    '16/10' => [ #'320x200', # CGA
		 #'640x400',
		 #'960x600',
		 '1280x800', 
		 '1440x900',
		 '1600x1000',
		 '1680x1050', # WSXGA+
		 '1920x1200', # WUXGA
		 '2560x1600', # WQXGA
		 '3840x2400', # WQUXGA
		 '5120x3200', # WHXGA
		 '7680x4800', # WHUXGA
	     ],

    # 1.67
    '15/9' => [ '800x480',
		'1280x768', # WXGA ?? should be 1366x768 ??
	    ],
    
    # 1.78
    '16/9' => [ #'854x480', # WVGA
	        #'960x540',
		#'1024x576',
		'1280x720', # HD 720		
		'1360x765', # one kind of WXGA (rounded down)
		'1366x768', # HDTV
		'1600x900', # WSXGA?
		'1920x1080', # HD 1080
		'7680x4320', # UHDTV
	    ],

    # now more weird things

    # 1.32
    # '192/145' => [ '1152x870' ],

    # 1.328
    # '85/64' => [ '1360x1024' ],

    # 1.42
    # '17/12' => [ '544x384' ] ,

    # 1.56
    #'25/16' => [ '1600x1024', # WSXGA
    #		 '3200x2048', # WQSXGA
    #		 '6400x4096', # WHSXGA
    #	     ], # (DBLSCAN 800x512)

    # 1.767
    # '53/30' => [ '848x480' ],

    # 1.775
    # '71/40' => [ '852x480' ],

    # 1.783
    # '107/60' => [ '856x480' ],

    N_("_:weird aspect ratio\nother") => [

	# 1.707 = 128/75
	'1024x600',

	# 1.771 = 85/48
	'1360x768',

	# 2.13 = 32/15
	'1024x480', '1280x600', # VAIO

	# 2.67 = 8/3
	'2048x768', '2560x960', '3200x1200',

	# 4.0 = 4/1
	'3072x768', '3456x864', '3840x960', '4800x1200',

	# ?? 352x288 640x350 (DBLSCAN 320x175) 720x400 (DBLSCAN 360x200)
    ],
);

our %resolution2ratio = map_each { map { $_ => $::a } @$::b } %ratio2resolutions;
our @resolutions = map_each { @$::b } %ratio2resolutions;

foreach my $ratio (keys %ratio2resolutions) {
    if ($ratio =~ m!^(\d+)/(\d+)$!) {
	my $eval = $2 / $1;
	foreach (@{$ratio2resolutions{$ratio}}) {
	    my ($x, $y) = /(\d+)x(\d+)/;
	    my $y2 = round($x * $eval);
	    $y == $y2 or do {
		my $good_ratio = (find { m!^(\d+)/(\d+)$! && $y == round($x * $2 / $1) } keys %ratio2resolutions) || '??';
		die "bad ratio $ratio for resolution $_, it should be $good_ratio\n";
	    };
	}
    }
}

our $default_header = <<'END';
# **********************************************************************
# Refer to the xorg.conf man page for details about the format of
# this file.
# **********************************************************************

Section "ServerFlags"
    Option "DontZap" "False" # disable <Ctrl><Alt><BS> (server abort)
    #DontZoom # disable <Ctrl><Alt><KP_+>/<KP_-> (resolution switching)
    AllowMouseOpenFail # allows the server to start up even if the mouse does not work
EndSection
Section "InputClass"
    Identifier      "Keyboard Defaults"
    MatchIsKeyboard "yes"
    Option          "XkbOptions" "terminate:ctrl_alt_bksp
END

require detect_devices;
$default_header .= <<'END_XBOX' if detect_devices::is_xbox();
    Option "PciProbe1" "false"
    Option "PciProbe2" "false"
    Option "PciForceConfig1" "false"
    Option "PciForceConfig2" "false"
    Option "PciOsConfig" "true"
END_XBOX

$default_header .= <<'END';
EndSection
END

our $default_ModeLine = arch() =~ /ppc/ ? <<'END_PPC' : <<'END';
    # Apple iMac modes
    ModeLine "1024x768"   78.525 1024 1049 1145 1312   768  769  772  800 +hsync +vsync
    ModeLine "800x600"    62.357  800  821  901 1040   600  601  604  632 +hsync +vsync
    ModeLine "640x480"    49.886  640  661  725  832   480  481  484  514 +hsync +vsync
    # Apple monitors tend to do 832x624
    ModeLine "832x624"    57      832  876  940 1152   624  625  628  667 -hsync -vsync
    # Apple PowerBook G3
    ModeLine "800x600"    100     800  816  824  840   600  616  624  640 -hsync -vsync
    # Apple TI Powerbook 
    ModeLine "1152x768"   78.741 1152 1173 1269 1440   768  769  772  800 +vsync +vsync
    # Pismo Firewire G3   
    ModeLine "1024x768"   65     1024 1032 1176 1344   768  771  777  806 -hsync -vsync
    # iBook2
    ModeLine "1024x768"   65     1024 1048 1184 1344   768  771  777  806 -hsync -vsync
    # 17" Apple Studio Display
    ModeLine "1024x768"   112.62 1024 1076 1248 1420 768 768 780 808 +hsync +vsync
    # HiRes Apple Studio Display
    ModeLine "1280x1024"  135    1280 1288 1392 1664  1024 1027 1030 1064
    # Another variation
    ModeLine "1280x1024"  134.989 1280 1317 1429 1688  1024 1025 1028 1066 +hsync +vsync
END_PPC
    # TV fullscreen mode or DVD fullscreen output.
    # 768x576 @ 79 Hz, 50 kHz hsync
    ModeLine "768x576"     50.00  768  832  846 1000   576  590  595  630
    # 768x576 @ 100 Hz, 61.6 kHz hsync
    ModeLine "768x576"     63.07  768  800  960 1024   576  578  590  616
END

1;
